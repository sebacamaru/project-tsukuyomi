import{C as e,Dn as t,E as n,Hn as r,Pn as i,Un as a,Wt as o,_t as s,bt as c,c as l,ct as u,f as d,h as f,i as ee,n as te,nt as p,p as ne,st as re,vt as ie,wt as m,x as ae,xt as oe,y as h,zt as g}from"./Filter-BEjgMG_t.js";import{r as _,t as v}from"./CanvasPool-CcMbyN3l.js";import{B as se,D as ce,F as le,I as ue,O as de,R as fe,W as pe,n as me,rt as y,t as he,tt as ge,z as _e}from"./SharedSystems-BiYNgiaQ.js";var b=l.for2d(),x=class{start(e,t,n){let r=e.renderer,i=r.encoder,a=n.gpuProgram;this._shader=n,this._geometry=t,i.setGeometry(t,a),b.blendMode=`normal`,r.pipeline.getPipeline(t,a,b);let o=r.globalUniforms.bindGroup;i.resetBindGroup(1),i.setBindGroup(0,o,a)}execute(e,t){let n=this._shader.gpuProgram,r=e.renderer,i=r.encoder;if(!t.bindGroup){let e=t.textures;t.bindGroup=_(e.textures,e.count,r.limits.maxBatchableTextures)}b.blendMode=t.blendMode;let a=r.bindGroup.getBindGroup(t.bindGroup,n,1),o=r.pipeline.getPipeline(this._geometry,n,b,t.topology);t.bindGroup._touch(r.textureGC.count),i.setPipeline(o),i.renderPassEncoder.setBindGroup(1,a),i.renderPassEncoder.drawIndexed(t.size,1,t.start)}};x.extension={type:[r.WebGPUPipesAdaptor],name:`batch`};var S=class{constructor(e){this._hash=Object.create(null),this._renderer=e,this._renderer.renderableGC.addManagedHash(this,`_hash`)}contextChange(e){this._gpu=e}getBindGroup(e,t,n){return e._updateKey(),this._hash[e._key]||this._createBindGroup(e,t,n)}_createBindGroup(e,t,n){let r=this._gpu.device,i=t.layout[n],a=[],o=this._renderer;for(let t in i){let n=e.resources[t]??e.resources[i[t]],r;if(n._resourceType===`uniformGroup`){let e=n;o.ubo.updateUniformGroup(e);let t=e.buffer;r={buffer:o.buffer.getGPUBuffer(t),offset:0,size:t.descriptor.size}}else if(n._resourceType===`buffer`){let e=n;r={buffer:o.buffer.getGPUBuffer(e),offset:0,size:e.descriptor.size}}else if(n._resourceType===`bufferResource`){let e=n;r={buffer:o.buffer.getGPUBuffer(e.buffer),offset:e.offset,size:e.size}}else if(n._resourceType===`textureSampler`){let e=n;r=o.texture.getGpuSampler(e)}else if(n._resourceType===`textureSource`){let e=n;r=o.texture.getGpuSource(e).createView({})}a.push({binding:i[t],resource:r})}let s=o.shader.getProgramData(t).bindGroups[n],c=r.createBindGroup({layout:s,entries:a});return this._hash[e._key]=c,c}destroy(){for(let e of Object.keys(this._hash))this._hash[e]=null;this._hash=null,this._renderer=null}};S.extension={type:[r.WebGPUSystem],name:`bindGroup`};var C=class{constructor(e){this._gpuBuffers=Object.create(null),e.renderableGC.addManagedHash(this,`_gpuBuffers`)}contextChange(e){this._gpu=e}getGPUBuffer(e){return this._gpuBuffers[e.uid]||this.createGPUBuffer(e)}updateBuffer(e){let t=this._gpuBuffers[e.uid]||this.createGPUBuffer(e),n=e.data;return e._updateID&&n&&(e._updateID=0,this._gpu.device.queue.writeBuffer(t,0,n.buffer,0,(e._updateSize||n.byteLength)+3&-4)),t}destroyAll(){for(let e in this._gpuBuffers)this._gpuBuffers[e]?.destroy();this._gpuBuffers={}}createGPUBuffer(e){this._gpuBuffers[e.uid]||(e.on(`update`,this.updateBuffer,this),e.on(`change`,this.onBufferChange,this),e.on(`destroy`,this.onBufferDestroy,this));let t=this._gpu.device.createBuffer(e.descriptor);return e._updateID=0,e.data&&(ie(e.data.buffer,t.getMappedRange()),t.unmap()),this._gpuBuffers[e.uid]=t,t}onBufferChange(e){this._gpuBuffers[e.uid].destroy(),e._updateID=0,this._gpuBuffers[e.uid]=this.createGPUBuffer(e)}onBufferDestroy(e){this._destroyBuffer(e)}destroy(){this.destroyAll(),this._gpuBuffers={}}_destroyBuffer(e){e.off(`update`,this.updateBuffer,this),e.off(`change`,this.onBufferChange,this),e.off(`destroy`,this.onBufferDestroy,this),this._gpuBuffers[e.uid]&&(this._gpuBuffers[e.uid].destroy(),this._gpuBuffers[e.uid]=null)}};C.extension={type:[r.WebGPUSystem],name:`buffer`};var w=class{constructor({minUniformOffsetAlignment:e}){this._minUniformOffsetAlignment=256,this.byteIndex=0,this._minUniformOffsetAlignment=e,this.data=new Float32Array(65535)}clear(){this.byteIndex=0}addEmptyGroup(e){if(e>this._minUniformOffsetAlignment/4)throw Error(`UniformBufferBatch: array is too large: ${e*4}`);let t=this.byteIndex,n=t+e*4;if(n=Math.ceil(n/this._minUniformOffsetAlignment)*this._minUniformOffsetAlignment,n>this.data.length*4)throw Error(`UniformBufferBatch: ubo batch got too big`);return this.byteIndex=n,t}addGroup(e){let t=this.addEmptyGroup(e.length);for(let n=0;n<e.length;n++)this.data[t/4+n]=e[n];return t}destroy(){this.data=null}},T=class{constructor(e){this._colorMaskCache=15,this._renderer=e}setMask(e){this._colorMaskCache!==e&&(this._colorMaskCache=e,this._renderer.pipeline.setColorMask(e))}destroy(){this._renderer=null,this._colorMaskCache=null}};T.extension={type:[r.WebGPUSystem],name:`colorMask`};var E=class{constructor(e){this._renderer=e}async init(e){return this._initPromise||=(e.gpu?Promise.resolve(e.gpu):this._createDeviceAndAdaptor(e)).then(e=>{this.gpu=e,this._renderer.runners.contextChange.emit(this.gpu)}),this._initPromise}contextChange(e){this._renderer.gpu=e}async _createDeviceAndAdaptor(e){let t=await m.get().getNavigator().gpu.requestAdapter({powerPreference:e.powerPreference,forceFallbackAdapter:e.forceFallbackAdapter}),n=[`texture-compression-bc`,`texture-compression-astc`,`texture-compression-etc2`].filter(e=>t.features.has(e));return{adapter:t,device:await t.requestDevice({requiredFeatures:n})}}destroy(){this.gpu=null,this._renderer=null}};E.extension={type:[r.WebGPUSystem],name:`device`},E.defaultOptions={powerPreference:void 0,forceFallbackAdapter:!1};var D=class{constructor(e){this._boundBindGroup=Object.create(null),this._boundVertexBuffer=Object.create(null),this._renderer=e}renderStart(){this.commandFinished=new Promise(e=>{this._resolveCommandFinished=e}),this.commandEncoder=this._renderer.gpu.device.createCommandEncoder()}beginRenderPass(e){this.endRenderPass(),this._clearCache(),this.renderPassEncoder=this.commandEncoder.beginRenderPass(e.descriptor)}endRenderPass(){this.renderPassEncoder&&this.renderPassEncoder.end(),this.renderPassEncoder=null}setViewport(e){this.renderPassEncoder.setViewport(e.x,e.y,e.width,e.height,0,1)}setPipelineFromGeometryProgramAndState(e,t,n,r){let i=this._renderer.pipeline.getPipeline(e,t,n,r);this.setPipeline(i)}setPipeline(e){this._boundPipeline!==e&&(this._boundPipeline=e,this.renderPassEncoder.setPipeline(e))}_setVertexBuffer(e,t){this._boundVertexBuffer[e]!==t&&(this._boundVertexBuffer[e]=t,this.renderPassEncoder.setVertexBuffer(e,this._renderer.buffer.updateBuffer(t)))}_setIndexBuffer(e){if(this._boundIndexBuffer===e)return;this._boundIndexBuffer=e;let t=e.data.BYTES_PER_ELEMENT===2?`uint16`:`uint32`;this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(e),t)}resetBindGroup(e){this._boundBindGroup[e]=null}setBindGroup(e,t,n){if(this._boundBindGroup[e]===t)return;this._boundBindGroup[e]=t,t._touch(this._renderer.textureGC.count);let r=this._renderer.bindGroup.getBindGroup(t,n,e);this.renderPassEncoder.setBindGroup(e,r)}setGeometry(e,t){let n=this._renderer.pipeline.getBufferNamesToBind(e,t);for(let t in n)this._setVertexBuffer(parseInt(t,10),e.attributes[n[t]].buffer);e.indexBuffer&&this._setIndexBuffer(e.indexBuffer)}_setShaderBindGroups(e,t){for(let n in e.groups){let r=e.groups[n];t||this._syncBindGroup(r),this.setBindGroup(n,r,e.gpuProgram)}}_syncBindGroup(e){for(let t in e.resources){let n=e.resources[t];n.isUniformGroup&&this._renderer.ubo.updateUniformGroup(n)}}draw(e){let{geometry:t,shader:n,state:r,topology:i,size:a,start:o,instanceCount:s,skipSync:c}=e;this.setPipelineFromGeometryProgramAndState(t,n.gpuProgram,r,i),this.setGeometry(t,n.gpuProgram),this._setShaderBindGroups(n,c),t.indexBuffer?this.renderPassEncoder.drawIndexed(a||t.indexBuffer.data.length,s??t.instanceCount,o||0):this.renderPassEncoder.draw(a||t.getSize(),s??t.instanceCount,o||0)}finishRenderPass(){this.renderPassEncoder&&=(this.renderPassEncoder.end(),null)}postrender(){this.finishRenderPass(),this._gpu.device.queue.submit([this.commandEncoder.finish()]),this._resolveCommandFinished(),this.commandEncoder=null}restoreRenderPass(){let e=this._renderer.renderTarget.adaptor.getDescriptor(this._renderer.renderTarget.renderTarget,!1,[0,0,0,1]);this.renderPassEncoder=this.commandEncoder.beginRenderPass(e);let t=this._boundPipeline,n={...this._boundVertexBuffer},r=this._boundIndexBuffer,i={...this._boundBindGroup};this._clearCache();let a=this._renderer.renderTarget.viewport;for(let e in this.renderPassEncoder.setViewport(a.x,a.y,a.width,a.height,0,1),this.setPipeline(t),n)this._setVertexBuffer(e,n[e]);for(let e in i)this.setBindGroup(e,i[e],null);this._setIndexBuffer(r)}_clearCache(){for(let e=0;e<16;e++)this._boundBindGroup[e]=null,this._boundVertexBuffer[e]=null;this._boundIndexBuffer=null,this._boundPipeline=null}destroy(){this._renderer=null,this._gpu=null,this._boundBindGroup=null,this._boundVertexBuffer=null,this._boundIndexBuffer=null,this._boundPipeline=null}contextChange(e){this._gpu=e}};D.extension={type:[r.WebGPUSystem],name:`encoder`,priority:1};var O=class{constructor(e){this._renderer=e}contextChange(){this.maxTextures=this._renderer.device.gpu.device.limits.maxSampledTexturesPerShaderStage,this.maxBatchableTextures=this.maxTextures}destroy(){}};O.extension={type:[r.WebGPUSystem],name:`limits`};var k=class{constructor(e){this._renderTargetStencilState=Object.create(null),this._renderer=e,e.renderTarget.onRenderTargetChange.add(this)}onRenderTargetChange(e){let t=this._renderTargetStencilState[e.uid];t||=this._renderTargetStencilState[e.uid]={stencilMode:s.DISABLED,stencilReference:0},this._activeRenderTarget=e,this.setStencilMode(t.stencilMode,t.stencilReference)}setStencilMode(e,t){let n=this._renderTargetStencilState[this._activeRenderTarget.uid];n.stencilMode=e,n.stencilReference=t;let r=this._renderer;r.pipeline.setStencilMode(e),r.encoder.renderPassEncoder.setStencilReference(t)}destroy(){this._renderer.renderTarget.onRenderTargetChange.remove(this),this._renderer=null,this._activeRenderTarget=null,this._renderTargetStencilState=null}};k.extension={type:[r.WebGPUSystem],name:`stencil`};var A={i32:{align:4,size:4},u32:{align:4,size:4},f32:{align:4,size:4},f16:{align:2,size:2},"vec2<i32>":{align:8,size:8},"vec2<u32>":{align:8,size:8},"vec2<f32>":{align:8,size:8},"vec2<f16>":{align:4,size:4},"vec3<i32>":{align:16,size:12},"vec3<u32>":{align:16,size:12},"vec3<f32>":{align:16,size:12},"vec3<f16>":{align:8,size:6},"vec4<i32>":{align:16,size:16},"vec4<u32>":{align:16,size:16},"vec4<f32>":{align:16,size:16},"vec4<f16>":{align:8,size:8},"mat2x2<f32>":{align:8,size:16},"mat2x2<f16>":{align:4,size:8},"mat3x2<f32>":{align:8,size:24},"mat3x2<f16>":{align:4,size:12},"mat4x2<f32>":{align:8,size:32},"mat4x2<f16>":{align:4,size:16},"mat2x3<f32>":{align:16,size:32},"mat2x3<f16>":{align:8,size:16},"mat3x3<f32>":{align:16,size:48},"mat3x3<f16>":{align:8,size:24},"mat4x3<f32>":{align:16,size:64},"mat4x3<f16>":{align:8,size:32},"mat2x4<f32>":{align:16,size:32},"mat2x4<f16>":{align:8,size:16},"mat3x4<f32>":{align:16,size:48},"mat3x4<f16>":{align:8,size:24},"mat4x4<f32>":{align:16,size:64},"mat4x4<f16>":{align:8,size:32}};function j(e){let t=e.map(e=>({data:e,offset:0,size:0})),n=0;for(let e=0;e<t.length;e++){let r=t[e],i=A[r.data.type].size,a=A[r.data.type].align;if(!A[r.data.type])throw Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${r.data.type}`);r.data.size>1&&(i=Math.max(i,a)*r.data.size),n=Math.ceil(n/a)*a,r.size=i,r.offset=n,n+=i}return n=Math.ceil(n/16)*16,{uboElements:t,size:n}}function M(e,t){let{size:n,align:r}=A[e.data.type],i=(r-n)/4,a=e.data.type.indexOf(`i32`)>=0?`dataInt32`:`data`;return`
         v = uv.${e.data.name};
         ${t===0?``:`offset += ${t};`}

         arrayOffset = offset;

         t = 0;

         for(var i=0; i < ${e.data.size*(n/4)}; i++)
         {
             for(var j = 0; j < ${n/4}; j++)
             {
                 ${a}[arrayOffset++] = v[t++];
             }
             ${i===0?``:`arrayOffset += ${i};`}
         }
     `}function N(e){return ue(e,`uboWgsl`,M,le)}var P=class extends fe{constructor(){super({createUboElements:j,generateUboSync:N})}};P.extension={type:[r.WebGPUSystem],name:`ubo`};var F=128,I=class{constructor(e){this._bindGroupHash=Object.create(null),this._buffers=[],this._bindGroups=[],this._bufferResources=[],this._renderer=e,this._renderer.renderableGC.addManagedHash(this,`_bindGroupHash`),this._batchBuffer=new w({minUniformOffsetAlignment:F});let t=256/F;for(let e=0;e<t;e++){let t=u.UNIFORM|u.COPY_DST;e===0&&(t|=u.COPY_SRC),this._buffers.push(new re({data:this._batchBuffer.data,usage:t}))}}renderEnd(){this._uploadBindGroups(),this._resetBindGroups()}_resetBindGroups(){for(let e in this._bindGroupHash)this._bindGroupHash[e]=null;this._batchBuffer.clear()}getUniformBindGroup(e,t){if(!t&&this._bindGroupHash[e.uid])return this._bindGroupHash[e.uid];this._renderer.ubo.ensureUniformGroup(e);let n=e.buffer.data,r=this._batchBuffer.addEmptyGroup(n.length);return this._renderer.ubo.syncUniformGroup(e,this._batchBuffer.data,r/4),this._bindGroupHash[e.uid]=this._getBindGroup(r/F),this._bindGroupHash[e.uid]}getUboResource(e){this._renderer.ubo.updateUniformGroup(e);let t=e.buffer.data,n=this._batchBuffer.addGroup(t);return this._getBufferResource(n/F)}getArrayBindGroup(e){let t=this._batchBuffer.addGroup(e);return this._getBindGroup(t/F)}getArrayBufferResource(e){let t=this._batchBuffer.addGroup(e)/F;return this._getBufferResource(t)}_getBufferResource(e){if(!this._bufferResources[e]){let t=this._buffers[e%2];this._bufferResources[e]=new ce({buffer:t,offset:(e/2|0)*256,size:F})}return this._bufferResources[e]}_getBindGroup(e){if(!this._bindGroups[e]){let t=new c({0:this._getBufferResource(e)});this._bindGroups[e]=t}return this._bindGroups[e]}_uploadBindGroups(){let e=this._renderer.buffer,t=this._buffers[0];t.update(this._batchBuffer.byteIndex),e.updateBuffer(t);let n=this._renderer.gpu.device.createCommandEncoder();for(let r=1;r<this._buffers.length;r++){let i=this._buffers[r];n.copyBufferToBuffer(e.getGPUBuffer(t),F,e.getGPUBuffer(i),0,this._batchBuffer.byteIndex)}this._renderer.gpu.device.queue.submit([n.finish()])}destroy(){for(let e=0;e<this._bindGroups.length;e++)this._bindGroups[e]?.destroy();this._bindGroups=null,this._bindGroupHash=null;for(let e=0;e<this._buffers.length;e++)this._buffers[e].destroy();this._buffers=null;for(let e=0;e<this._bufferResources.length;e++)this._bufferResources[e].destroy();this._bufferResources=null,this._batchBuffer.destroy(),this._bindGroupHash=null,this._renderer=null}};I.extension={type:[r.WebGPUPipes],name:`uniformBatch`};var ve={"point-list":0,"line-list":1,"line-strip":2,"triangle-list":3,"triangle-strip":4};function ye(e,t,n,r,i){return e<<24|t<<16|n<<10|r<<5|i}function be(e,t,n,r){return n<<6|e<<3|r<<1|t}var L=class{constructor(e){this._moduleCache=Object.create(null),this._bufferLayoutsCache=Object.create(null),this._bindingNamesCache=Object.create(null),this._pipeCache=Object.create(null),this._pipeStateCaches=Object.create(null),this._colorMask=15,this._multisampleCount=1,this._renderer=e}contextChange(e){this._gpu=e,this.setStencilMode(s.DISABLED),this._updatePipeHash()}setMultisampleCount(e){this._multisampleCount!==e&&(this._multisampleCount=e,this._updatePipeHash())}setRenderTarget(e){this._multisampleCount=e.msaaSamples,this._depthStencilAttachment=e.descriptor.depthStencilAttachment?1:0,this._updatePipeHash()}setColorMask(e){this._colorMask!==e&&(this._colorMask=e,this._updatePipeHash())}setStencilMode(e){this._stencilMode!==e&&(this._stencilMode=e,this._stencilState=_e[e],this._updatePipeHash())}setPipeline(e,t,n,r){let i=this.getPipeline(e,t,n);r.setPipeline(i)}getPipeline(e,t,n,r){e._layoutKey||(se(e,t.attributeData),this._generateBufferKey(e)),r||=e.topology;let i=ye(e._layoutKey,t._layoutKey,n.data,n._blendModeId,ve[r]);return this._pipeCache[i]||(this._pipeCache[i]=this._createPipeline(e,t,n,r)),this._pipeCache[i]}_createPipeline(e,t,n,r){let i=this._gpu.device,a=this._createVertexBufferLayouts(e,t),o=this._renderer.state.getColorTargets(n);o[0].writeMask=this._stencilMode===s.RENDERING_MASK_ADD?0:this._colorMask;let c=this._renderer.shader.getProgramData(t).pipeline,l={vertex:{module:this._getModule(t.vertex.source),entryPoint:t.vertex.entryPoint,buffers:a},fragment:{module:this._getModule(t.fragment.source),entryPoint:t.fragment.entryPoint,targets:o},primitive:{topology:r,cullMode:n.cullMode},layout:c,multisample:{count:this._multisampleCount},label:`PIXI Pipeline`};return this._depthStencilAttachment&&(l.depthStencil={...this._stencilState,format:`depth24plus-stencil8`,depthWriteEnabled:n.depthTest,depthCompare:n.depthTest?`less`:`always`}),i.createRenderPipeline(l)}_getModule(e){return this._moduleCache[e]||this._createModule(e)}_createModule(e){let t=this._gpu.device;return this._moduleCache[e]=t.createShaderModule({code:e}),this._moduleCache[e]}_generateBufferKey(e){let t=[],n=0,r=Object.keys(e.attributes).sort();for(let i=0;i<r.length;i++){let a=e.attributes[r[i]];t[n++]=a.offset,t[n++]=a.format,t[n++]=a.stride,t[n++]=a.instance}return e._layoutKey=p(t.join(`|`),`geometry`),e._layoutKey}_generateAttributeLocationsKey(e){let t=[],n=0,r=Object.keys(e.attributeData).sort();for(let i=0;i<r.length;i++){let a=e.attributeData[r[i]];t[n++]=a.location}return e._attributeLocationsKey=p(t.join(`|`),`programAttributes`),e._attributeLocationsKey}getBufferNamesToBind(e,t){let n=e._layoutKey<<16|t._attributeLocationsKey;if(this._bindingNamesCache[n])return this._bindingNamesCache[n];let r=this._createVertexBufferLayouts(e,t),i=Object.create(null),a=t.attributeData;for(let e=0;e<r.length;e++){let t=Object.values(r[e].attributes)[0].shaderLocation;for(let n in a)if(a[n].location===t){i[e]=n;break}}return this._bindingNamesCache[n]=i,i}_createVertexBufferLayouts(e,n){n._attributeLocationsKey||this._generateAttributeLocationsKey(n);let r=e._layoutKey<<16|n._attributeLocationsKey;if(this._bufferLayoutsCache[r])return this._bufferLayoutsCache[r];let i=[];return e.buffers.forEach(r=>{let a={arrayStride:0,stepMode:`vertex`,attributes:[]},o=a.attributes;for(let i in n.attributeData){let s=e.attributes[i];(s.divisor??1)!==1&&t(`Attribute ${i} has an invalid divisor value of '${s.divisor}'. WebGPU only supports a divisor value of 1`),s.buffer===r&&(a.arrayStride=s.stride,a.stepMode=s.instance?`instance`:`vertex`,o.push({shaderLocation:n.attributeData[i].location,offset:s.offset,format:s.format}))}o.length&&i.push(a)}),this._bufferLayoutsCache[r]=i,i}_updatePipeHash(){let e=be(this._stencilMode,this._multisampleCount,this._colorMask,this._depthStencilAttachment);this._pipeStateCaches[e]||(this._pipeStateCaches[e]=Object.create(null)),this._pipeCache=this._pipeStateCaches[e]}destroy(){this._renderer=null,this._bufferLayoutsCache=null}};L.extension={type:[r.WebGPUSystem],name:`pipeline`};var R=class{constructor(){this.contexts=[],this.msaaTextures=[],this.msaaSamples=1}},z=class{init(e,t){this._renderer=e,this._renderTargetSystem=t}copyToTexture(e,t,n,r,i){let a=this._renderer,o=this._getGpuColorTexture(e),s=a.texture.getGpuSource(t.source);return a.encoder.commandEncoder.copyTextureToTexture({texture:o,origin:n},{texture:s,origin:i},r),t}startRenderPass(e,t=!0,n,r){let i=this._renderTargetSystem.getGpuRenderTarget(e);i.descriptor=this.getDescriptor(e,t,n),this._renderer.pipeline.setRenderTarget(i),this._renderer.encoder.beginRenderPass(i),this._renderer.encoder.setViewport(r)}finishRenderPass(){this._renderer.encoder.endRenderPass()}_getGpuColorTexture(e){let t=this._renderTargetSystem.getGpuRenderTarget(e);return t.contexts[0]?t.contexts[0].getCurrentTexture():this._renderer.texture.getGpuSource(e.colorTextures[0].source)}getDescriptor(e,t,n){typeof t==`boolean`&&(t=t?y.ALL:y.NONE);let r=this._renderTargetSystem,i=r.getGpuRenderTarget(e),a=e.colorTextures.map((e,a)=>{let o=i.contexts[a],s,c;s=o?o.getCurrentTexture().createView():this._renderer.texture.getGpuSource(e).createView({mipLevelCount:1}),i.msaaTextures[a]&&(c=s,s=this._renderer.texture.getTextureView(i.msaaTextures[a]));let l=t&y.COLOR?`clear`:`load`;return n??=r.defaultClearColor,{view:s,resolveTarget:c,clearValue:n,storeOp:`store`,loadOp:l}}),o;if((e.stencil||e.depth)&&!e.depthStencilTexture&&(e.ensureDepthStencilTexture(),e.depthStencilTexture.source.sampleCount=i.msaa?4:1),e.depthStencilTexture){let n=t&y.STENCIL?`clear`:`load`,r=t&y.DEPTH?`clear`:`load`;o={view:this._renderer.texture.getGpuSource(e.depthStencilTexture.source).createView(),stencilStoreOp:`store`,stencilLoadOp:n,depthClearValue:1,depthLoadOp:r,depthStoreOp:`store`}}return{colorAttachments:a,depthStencilAttachment:o}}clear(e,t=!0,n,r){if(!t)return;let{gpu:i,encoder:a}=this._renderer,o=i.device;if(a.commandEncoder===null){let i=o.createCommandEncoder(),a=this.getDescriptor(e,t,n),s=i.beginRenderPass(a);s.setViewport(r.x,r.y,r.width,r.height,0,1),s.end();let c=i.finish();o.queue.submit([c])}else this.startRenderPass(e,t,n,r)}initGpuRenderTarget(e){e.isRoot=!0;let t=new R;return e.colorTextures.forEach((e,n)=>{if(e instanceof oe){let r=e.resource.getContext(`webgpu`),i=e.transparent?`premultiplied`:`opaque`;try{r.configure({device:this._renderer.gpu.device,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC,format:`bgra8unorm`,alphaMode:i})}catch(e){console.error(e)}t.contexts[n]=r}if(t.msaa=e.source.antialias,e.source.antialias){let e=new o({width:0,height:0,sampleCount:4});t.msaaTextures[n]=e}}),t.msaa&&(t.msaaSamples=4,e.depthStencilTexture&&(e.depthStencilTexture.source.sampleCount=4)),t}destroyGpuRenderTarget(e){e.contexts.forEach(e=>{e.unconfigure()}),e.msaaTextures.forEach(e=>{e.destroy()}),e.msaaTextures.length=0,e.contexts.length=0}ensureDepthStencilTexture(e){let t=this._renderTargetSystem.getGpuRenderTarget(e);e.depthStencilTexture&&t.msaa&&(e.depthStencilTexture.source.sampleCount=4)}resizeGpuRenderTarget(e){let t=this._renderTargetSystem.getGpuRenderTarget(e);t.width=e.width,t.height=e.height,t.msaa&&e.colorTextures.forEach((e,n)=>{t.msaaTextures[n]?.resize(e.source.width,e.source.height,e.source._resolution)})}},B=class extends de{constructor(e){super(e),this.adaptor=new z,this.adaptor.init(e,this)}};B.extension={type:[r.WebGPUSystem],name:`renderTarget`};var V=class{constructor(){this._gpuProgramData=Object.create(null)}contextChange(e){this._gpu=e}getProgramData(e){return this._gpuProgramData[e._layoutKey]||this._createGPUProgramData(e)}_createGPUProgramData(e){let t=this._gpu.device,n=e.gpuLayout.map(e=>t.createBindGroupLayout({entries:e})),r={bindGroupLayouts:n};return this._gpuProgramData[e._layoutKey]={bindGroups:n,pipeline:t.createPipelineLayout(r)},this._gpuProgramData[e._layoutKey]}destroy(){this._gpu=null,this._gpuProgramData=null}};V.extension={type:[r.WebGPUSystem],name:`shader`};var H={};H.normal={alpha:{srcFactor:`one`,dstFactor:`one-minus-src-alpha`,operation:`add`},color:{srcFactor:`one`,dstFactor:`one-minus-src-alpha`,operation:`add`}},H.add={alpha:{srcFactor:`src-alpha`,dstFactor:`one-minus-src-alpha`,operation:`add`},color:{srcFactor:`one`,dstFactor:`one`,operation:`add`}},H.multiply={alpha:{srcFactor:`one`,dstFactor:`one-minus-src-alpha`,operation:`add`},color:{srcFactor:`dst`,dstFactor:`one-minus-src-alpha`,operation:`add`}},H.screen={alpha:{srcFactor:`one`,dstFactor:`one-minus-src-alpha`,operation:`add`},color:{srcFactor:`one`,dstFactor:`one-minus-src`,operation:`add`}},H.overlay={alpha:{srcFactor:`one`,dstFactor:`one-minus-src-alpha`,operation:`add`},color:{srcFactor:`one`,dstFactor:`one-minus-src`,operation:`add`}},H.none={alpha:{srcFactor:`one`,dstFactor:`one-minus-src-alpha`,operation:`add`},color:{srcFactor:`zero`,dstFactor:`zero`,operation:`add`}},H[`normal-npm`]={alpha:{srcFactor:`one`,dstFactor:`one-minus-src-alpha`,operation:`add`},color:{srcFactor:`src-alpha`,dstFactor:`one-minus-src-alpha`,operation:`add`}},H[`add-npm`]={alpha:{srcFactor:`one`,dstFactor:`one`,operation:`add`},color:{srcFactor:`src-alpha`,dstFactor:`one`,operation:`add`}},H[`screen-npm`]={alpha:{srcFactor:`one`,dstFactor:`one-minus-src-alpha`,operation:`add`},color:{srcFactor:`src-alpha`,dstFactor:`one-minus-src`,operation:`add`}},H.erase={alpha:{srcFactor:`zero`,dstFactor:`one-minus-src-alpha`,operation:`add`},color:{srcFactor:`zero`,dstFactor:`one-minus-src`,operation:`add`}},H.min={alpha:{srcFactor:`one`,dstFactor:`one`,operation:`min`},color:{srcFactor:`one`,dstFactor:`one`,operation:`min`}},H.max={alpha:{srcFactor:`one`,dstFactor:`one`,operation:`max`},color:{srcFactor:`one`,dstFactor:`one`,operation:`max`}};var U=class{constructor(){this.defaultState=new l,this.defaultState.blend=!0}contextChange(e){this.gpu=e}getColorTargets(e){return[{format:`bgra8unorm`,writeMask:0,blend:H[e.blendMode]||H.normal}]}destroy(){this.gpu=null}};U.extension={type:[r.WebGPUSystem],name:`state`};var W={type:`image`,upload(e,t,n){let r=e.resource,i=(e.pixelWidth|0)*(e.pixelHeight|0),a=r.byteLength/i;n.device.queue.writeTexture({texture:t},r,{offset:0,rowsPerImage:e.pixelHeight,bytesPerRow:e.pixelWidth*a},{width:e.pixelWidth,height:e.pixelHeight,depthOrArrayLayers:1})}},G={"bc1-rgba-unorm":{blockBytes:8,blockWidth:4,blockHeight:4},"bc2-rgba-unorm":{blockBytes:16,blockWidth:4,blockHeight:4},"bc3-rgba-unorm":{blockBytes:16,blockWidth:4,blockHeight:4},"bc7-rgba-unorm":{blockBytes:16,blockWidth:4,blockHeight:4},"etc1-rgb-unorm":{blockBytes:8,blockWidth:4,blockHeight:4},"etc2-rgba8unorm":{blockBytes:16,blockWidth:4,blockHeight:4},"astc-4x4-unorm":{blockBytes:16,blockWidth:4,blockHeight:4}},xe={blockBytes:4,blockWidth:1,blockHeight:1},K={type:`compressed`,upload(e,t,n){let r=e.pixelWidth,i=e.pixelHeight,a=G[e.format]||xe;for(let o=0;o<e.resource.length;o++){let s=e.resource[o],c=Math.ceil(r/a.blockWidth)*a.blockBytes;n.device.queue.writeTexture({texture:t,mipLevel:o},s,{offset:0,bytesPerRow:c},{width:Math.ceil(r/a.blockWidth)*a.blockWidth,height:Math.ceil(i/a.blockHeight)*a.blockHeight,depthOrArrayLayers:1}),r=Math.max(r>>1,1),i=Math.max(i>>1,1)}}},q={type:`image`,upload(e,n,r){let i=e.resource;if(!i)return;if(globalThis.HTMLImageElement&&i instanceof HTMLImageElement){let n=m.get().createCanvas(i.width,i.height);n.getContext(`2d`).drawImage(i,0,0,i.width,i.height),e.resource=n,t(`ImageSource: Image element passed, converting to canvas and replacing resource.`)}let a=Math.min(n.width,e.resourceWidth||e.pixelWidth),o=Math.min(n.height,e.resourceHeight||e.pixelHeight),s=e.alphaMode===`premultiply-alpha-on-upload`;r.device.queue.copyExternalImageToTexture({source:i},{texture:n,premultipliedAlpha:s},{width:a,height:o})}},J={type:`video`,upload(e,t,n){q.upload(e,t,n)}},Y=class{constructor(e){this.device=e,this.sampler=e.createSampler({minFilter:`linear`}),this.pipelines={}}_getMipmapPipeline(e){let t=this.pipelines[e];return t||(this.mipmapShaderModule||=this.device.createShaderModule({code:`
                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(
                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));

                        struct VertexOutput {
                        @builtin(position) position : vec4<f32>,
                        @location(0) texCoord : vec2<f32>,
                        };

                        @vertex
                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
                        var output : VertexOutput;
                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
                        return output;
                        }

                        @group(0) @binding(0) var imgSampler : sampler;
                        @group(0) @binding(1) var img : texture_2d<f32>;

                        @fragment
                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
                        return textureSample(img, imgSampler, texCoord);
                        }
                    `}),t=this.device.createRenderPipeline({layout:`auto`,vertex:{module:this.mipmapShaderModule,entryPoint:`vertexMain`},fragment:{module:this.mipmapShaderModule,entryPoint:`fragmentMain`,targets:[{format:e}]}}),this.pipelines[e]=t),t}generateMipmap(e){let t=this._getMipmapPipeline(e.format);if(e.dimension===`3d`||e.dimension===`1d`)throw Error(`Generating mipmaps for non-2d textures is currently unsupported!`);let n=e,r=e.depthOrArrayLayers||1,i=e.usage&GPUTextureUsage.RENDER_ATTACHMENT;if(!i){let t={size:{width:Math.ceil(e.width/2),height:Math.ceil(e.height/2),depthOrArrayLayers:r},format:e.format,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.RENDER_ATTACHMENT,mipLevelCount:e.mipLevelCount-1};n=this.device.createTexture(t)}let a=this.device.createCommandEncoder({}),o=t.getBindGroupLayout(0);for(let s=0;s<r;++s){let r=e.createView({baseMipLevel:0,mipLevelCount:1,dimension:`2d`,baseArrayLayer:s,arrayLayerCount:1}),c=i?1:0;for(let i=1;i<e.mipLevelCount;++i){let e=n.createView({baseMipLevel:c++,mipLevelCount:1,dimension:`2d`,baseArrayLayer:s,arrayLayerCount:1}),i=a.beginRenderPass({colorAttachments:[{view:e,storeOp:`store`,loadOp:`clear`,clearValue:{r:0,g:0,b:0,a:0}}]}),l=this.device.createBindGroup({layout:o,entries:[{binding:0,resource:this.sampler},{binding:1,resource:r}]});i.setPipeline(t),i.setBindGroup(0,l),i.draw(3,1,0,0),i.end(),r=e}}if(!i){let t={width:Math.ceil(e.width/2),height:Math.ceil(e.height/2),depthOrArrayLayers:r};for(let r=1;r<e.mipLevelCount;++r)a.copyTextureToTexture({texture:n,mipLevel:r-1},{texture:e,mipLevel:r},t),t.width=Math.ceil(t.width/2),t.height=Math.ceil(t.height/2)}return this.device.queue.submit([a.finish()]),i||n.destroy(),e}},X=class{constructor(e){this.managedTextures=[],this._gpuSources=Object.create(null),this._gpuSamplers=Object.create(null),this._bindGroupHash=Object.create(null),this._textureViewHash=Object.create(null),this._uploads={image:q,buffer:W,video:J,compressed:K},this._renderer=e,e.renderableGC.addManagedHash(this,`_gpuSources`),e.renderableGC.addManagedHash(this,`_gpuSamplers`),e.renderableGC.addManagedHash(this,`_bindGroupHash`),e.renderableGC.addManagedHash(this,`_textureViewHash`)}contextChange(e){this._gpu=e}initSource(e){return this._gpuSources[e.uid]?this._gpuSources[e.uid]:this._initSource(e)}_initSource(e){if(e.autoGenerateMipmaps){let t=Math.max(e.pixelWidth,e.pixelHeight);e.mipLevelCount=Math.floor(Math.log2(t))+1}let t=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST;e.uploadMethodId!==`compressed`&&(t|=GPUTextureUsage.RENDER_ATTACHMENT,t|=GPUTextureUsage.COPY_SRC);let n=G[e.format]||{blockBytes:4,blockWidth:1,blockHeight:1},r=Math.ceil(e.pixelWidth/n.blockWidth)*n.blockWidth,i=Math.ceil(e.pixelHeight/n.blockHeight)*n.blockHeight,a={label:e.label,size:{width:r,height:i},format:e.format,sampleCount:e.sampleCount,mipLevelCount:e.mipLevelCount,dimension:e.dimension,usage:t},o=this._gpuSources[e.uid]=this._gpu.device.createTexture(a);return this.managedTextures.includes(e)||(e.on(`update`,this.onSourceUpdate,this),e.on(`resize`,this.onSourceResize,this),e.on(`destroy`,this.onSourceDestroy,this),e.on(`unload`,this.onSourceUnload,this),e.on(`updateMipmaps`,this.onUpdateMipmaps,this),this.managedTextures.push(e)),this.onSourceUpdate(e),o}onSourceUpdate(e){let t=this.getGpuSource(e);t&&(this._uploads[e.uploadMethodId]&&this._uploads[e.uploadMethodId].upload(e,t,this._gpu),e.autoGenerateMipmaps&&e.mipLevelCount>1&&this.onUpdateMipmaps(e))}onSourceUnload(e){let t=this._gpuSources[e.uid];t&&(this._gpuSources[e.uid]=null,t.destroy())}onUpdateMipmaps(e){this._mipmapGenerator||=new Y(this._gpu.device);let t=this.getGpuSource(e);this._mipmapGenerator.generateMipmap(t)}onSourceDestroy(e){e.off(`update`,this.onSourceUpdate,this),e.off(`unload`,this.onSourceUnload,this),e.off(`destroy`,this.onSourceDestroy,this),e.off(`resize`,this.onSourceResize,this),e.off(`updateMipmaps`,this.onUpdateMipmaps,this),this.managedTextures.splice(this.managedTextures.indexOf(e),1),this.onSourceUnload(e)}onSourceResize(e){let t=this._gpuSources[e.uid];t?(t.width!==e.pixelWidth||t.height!==e.pixelHeight)&&(this._textureViewHash[e.uid]=null,this._bindGroupHash[e.uid]=null,this.onSourceUnload(e),this.initSource(e)):this.initSource(e)}_initSampler(e){return this._gpuSamplers[e._resourceId]=this._gpu.device.createSampler(e),this._gpuSamplers[e._resourceId]}getGpuSampler(e){return this._gpuSamplers[e._resourceId]||this._initSampler(e)}getGpuSource(e){return this._gpuSources[e.uid]||this.initSource(e)}getTextureBindGroup(e){return this._bindGroupHash[e.uid]??this._createTextureBindGroup(e)}_createTextureBindGroup(e){let t=e.source;return this._bindGroupHash[e.uid]=new c({0:t,1:t.style,2:new f({uTextureMatrix:{type:`mat3x3<f32>`,value:e.textureMatrix.mapCoord}})}),this._bindGroupHash[e.uid]}getTextureView(e){let t=e.source;return this._textureViewHash[t.uid]??this._createTextureView(t)}_createTextureView(e){return this._textureViewHash[e.uid]=this.getGpuSource(e).createView(),this._textureViewHash[e.uid]}generateCanvas(e){let t=this._renderer,n=t.gpu.device.createCommandEncoder(),r=m.get().createCanvas();r.width=e.source.pixelWidth,r.height=e.source.pixelHeight;let i=r.getContext(`webgpu`);return i.configure({device:t.gpu.device,usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC,format:m.get().getNavigator().gpu.getPreferredCanvasFormat(),alphaMode:`premultiplied`}),n.copyTextureToTexture({texture:t.texture.getGpuSource(e.source),origin:{x:0,y:0}},{texture:i.getCurrentTexture()},{width:r.width,height:r.height}),t.gpu.device.queue.submit([n.finish()]),r}getPixels(e){let t=this.generateCanvas(e),n=v.getOptimalCanvasAndContext(t.width,t.height),r=n.context;r.drawImage(t,0,0);let{width:i,height:a}=t,o=r.getImageData(0,0,i,a),s=new Uint8ClampedArray(o.data.buffer);return v.returnCanvasAndContext(n),{pixels:s,width:i,height:a}}destroy(){this.managedTextures.slice().forEach(e=>this.onSourceDestroy(e)),this.managedTextures=null;for(let e of Object.keys(this._bindGroupHash)){let t=Number(e);this._bindGroupHash[t]?.destroy(),this._bindGroupHash[t]=null}this._renderer=null,this._gpu=null,this._mipmapGenerator=null,this._gpuSources=null,this._bindGroupHash=null,this._textureViewHash=null,this._gpuSamplers=null}};X.extension={type:[r.WebGPUSystem],name:`texture`};var Z=class{constructor(){this._maxTextures=0}contextChange(t){let r=new f({uTransformMatrix:{value:new i,type:`mat3x3<f32>`},uColor:{value:new Float32Array([1,1,1,1]),type:`vec4<f32>`},uRound:{value:0,type:`f32`}});this._maxTextures=t.limits.maxBatchableTextures,this.shader=new d({gpuProgram:n({name:`graphics`,bits:[e,ae(this._maxTextures),ee,h]}),resources:{localUniforms:r}})}execute(e,t){let n=t.context,r=n.customShader||this.shader,i=e.renderer,{batcher:a,instructions:o}=i.graphicsContext.getContextRenderData(n),s=i.encoder;s.setGeometry(a.geometry,r.gpuProgram);let c=i.globalUniforms.bindGroup;s.setBindGroup(0,c,r.gpuProgram);let l=i.renderPipes.uniformBatch.getUniformBindGroup(r.resources.localUniforms,!0);s.setBindGroup(2,l,r.gpuProgram);let u=o.instructions,d=null;for(let t=0;t<o.instructionSize;t++){let n=u[t];if(n.topology!==d&&(d=n.topology,s.setPipelineFromGeometryProgramAndState(a.geometry,r.gpuProgram,e.state,n.topology)),r.groups[1]=n.bindGroup,!n.gpuBindGroup){let e=n.textures;n.bindGroup=_(e.textures,e.count,this._maxTextures),n.gpuBindGroup=i.bindGroup.getBindGroup(n.bindGroup,r.gpuProgram,1)}s.setBindGroup(1,n.bindGroup,r.gpuProgram),s.renderPassEncoder.drawIndexed(n.size,1,n.start)}}destroy(){this.shader.destroy(!0),this.shader=null}};Z.extension={type:[r.WebGPUPipesAdaptor],name:`graphics`};var Q=class{init(){this._shader=new d({gpuProgram:n({name:`mesh`,bits:[te,pe,h]}),resources:{uTexture:g.EMPTY._source,uSampler:g.EMPTY._source.style,textureUniforms:{uTextureMatrix:{type:`mat3x3<f32>`,value:new i}}}})}execute(e,n){let r=e.renderer,i=n._shader;if(!i)i=this._shader,i.groups[2]=r.texture.getTextureBindGroup(n.texture);else if(!i.gpuProgram){t(`Mesh shader has no gpuProgram`,n.shader);return}let a=i.gpuProgram;if(a.autoAssignGlobalUniforms&&(i.groups[0]=r.globalUniforms.bindGroup),a.autoAssignLocalUniforms){let t=e.localUniforms;i.groups[1]=r.renderPipes.uniformBatch.getUniformBindGroup(t,!0)}r.encoder.draw({geometry:n._geometry,shader:i,state:n.state})}destroy(){this._shader.destroy(!0),this._shader=null}};Q.extension={type:[r.WebGPUPipesAdaptor],name:`mesh`};var Se=[...me,P,D,E,O,C,X,B,V,U,L,T,k,S],Ce=[...he,I],we=[x,Q,Z],Te=[],Ee=[],$=[];a.handleByNamedList(r.WebGPUSystem,Te),a.handleByNamedList(r.WebGPUPipes,Ee),a.handleByNamedList(r.WebGPUPipesAdaptor,$),a.add(...Se,...Ce,...we);var De=class extends ge{constructor(){let e={name:`webgpu`,type:ne.WEBGPU,systems:Te,renderPipes:Ee,renderPipeAdaptors:$};super(e)}};export{C as A,j as C,E as D,D as E,x as M,T as O,A as S,O as T,L as _,Y as a,N as b,G as c,U as d,H as f,R as g,z as h,X as i,S as j,w as k,K as l,B as m,Q as n,J as o,V as p,Z as r,q as s,De as t,W as u,I as v,k as w,M as x,P as y};